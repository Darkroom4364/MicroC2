<!DOCTYPE html>
<html>
<head>
    <title>MicroC2 - Listeners</title>
    <link rel="stylesheet" href="/home/css/styles.css">
    <link rel="stylesheet" href="/home/css/components.css">
    <style>
        /* Enhanced error styling */
        .status-message.error {
            background-color: rgba(255, 50, 50, 0.9);
            color: white;
            border-left: 4px solid #f00;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .status-message.error ul {
            margin: 10px 0 5px 20px;
            text-align: left;
        }
        
        .error-details {
            margin-top: 10px;
            padding: 8px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 4px;
        }
        
        .error-diagnostic {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px;
            font-size: 12px;
            text-align: left;
        }
        
        .error-diagnostic details {
            margin-top: 8px;
        }
        
        .error-diagnostic pre {
            background-color: #333;
            padding: 8px;
            border-radius: 4px;
            margin-top: 5px;
            overflow: auto;
            max-height: 200px;
            font-size: 11px;
        }
        
        /* Status indicators for listener states */
        .status-active {
            color: #4caf50;
            font-weight: bold;
        }
        
        .status-stopped {
            color: #ff9800;
            font-weight: bold;
        }
        
        .status-error {
            color: #f44336;
            font-weight: bold;
        }
        
        .status-unknown {
            color: #9e9e9e;
            font-style: italic;
        }
        
        /* Improved listener card styling */
        .listener-card {
            position: relative;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            background-color: #2a2a2a;
            transition: all 0.2s ease;
        }
        
        .listener-card:hover {
            background-color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="havoc-container">
        <div class="sidebar">
            <div class="nav-header">MICROC2 CONSOLE</div>
            <div class="nav-item" onclick="window.location.href='/home/index.html'">Mission Control</div>
            <div class="nav-item active">Listeners</div>
            <div class="nav-item" onclick="window.location.href='/home/payload.html'">Payload</div>
            <div class="nav-item" onclick="window.location.href='/home/file_drop.html'">File Drop</div>
            <div class="nav-item" onclick="window.location.href='/home/server_terminal.html'">Server Terminal</div>
        </div>

        <div class="content">
            <div class="top-panel">
                <div class="config-panel">
                    <h2>Listener Configuration</h2>
                    <form id="listenerForm" class="config-form">
                        <div class="form-section">
                            <h3>Basic Settings</h3>
                            <div class="form-group">
                                <label for="listenerName">Name:</label>
                                <input type="text" id="listenerName" name="listenerName" required placeholder="base - http">
                            </div>
                            
                            <div class="form-group">
                                <label for="payloadType">Payload:</label>
                                <select id="payloadType" name="payloadType" required class="dark-select">
                                    <option value="https">HTTPS</option>
                                    <option value="http">HTTP</option>
                                    <option value="dns">DNS over HTTPS</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-section">
                            <h3>Config Options</h3>
                            <div class="form-group">
                                <label for="hostInput">Hosts</label>
                                <div class="input-with-buttons">
                                    <input type="text" id="hostInput" placeholder="domain.com or IP address" class="dark-input">
                                    <div class="button-group">
                                        <button type="button" class="action-button purple" onclick="addListItem('hostInput', 'hostsList', 'hosts')">Add</button>
                                        <button type="button" class="action-button purple" onclick="clearList('hostsList', 'hosts')">Clear</button>
                                    </div>
                                </div>
                                <div id="hostsList" class="items-list"></div>
                                <input type="hidden" id="hosts" name="hosts">
                            </div>

                            <div class="form-group">
                                <label for="hostRotation">Host Rotation:</label>
                                <select id="hostRotation" name="hostRotation" class="dark-select">
                                    <option value="round-robin">round-robin</option>
                                    <option value="random">random</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="bindHost">Host (Bind):</label>
                                <input type="text" id="bindHost" name="bindHost" placeholder="0.0.0.0 or specific IP address" class="dark-input" value="0.0.0.0">
                                <small class="form-text text-muted">Use 0.0.0.0 to bind to all interfaces</small>
                            </div>

                            <div class="form-group">
                                <label for="port">Port:</label>
                                <input type="number" id="port" name="port" value="8443" class="dark-input" min="1024" max="65535">
                                <small class="form-text text-muted">Use ports above 1024 for non-root access</small>
                            </div>

                            <div class="form-group">
                                <label for="userAgent">User Agent:</label>
                                <input type="text" id="userAgent" name="userAgent" class="dark-input" 
                                       value="Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36">
                            </div>

                            <div class="form-group">
                                <label for="headerInput">Headers:</label>
                                <div class="input-with-buttons">
                                    <input type="text" id="headerInput" placeholder="X-Header: Value" class="dark-input">
                                    <div class="button-group">
                                        <button type="button" class="action-button purple" onclick="addListItem('headerInput', 'headersList', 'headers')">Add</button>
                                        <button type="button" class="action-button purple" onclick="clearList('headersList', 'headers')">Clear</button>
                                    </div>
                                </div>
                                <div id="headersList" class="items-list"></div>
                                <input type="hidden" id="headers" name="headers">
                            </div>

                            <div class="form-group">
                                <label for="uriInput">URIs:</label>
                                <div class="input-with-buttons">
                                    <input type="text" id="uriInput" placeholder="/index.php or /images/logo.png" class="dark-input">
                                    <div class="button-group">
                                        <button type="button" class="action-button purple" onclick="addListItem('uriInput', 'urisList', 'uris')">Add</button>
                                        <button type="button" class="action-button purple" onclick="clearList('urisList', 'uris')">Clear</button>
                                    </div>
                                </div>
                                <div id="urisList" class="items-list"></div>
                                <input type="hidden" id="uris" name="uris">
                            </div>

                            <div class="form-group">
                                <label for="hostHeader">Host Header:</label>
                                <input type="text" id="hostHeader" name="hostHeader" class="dark-input">
                            </div>
                        </div>

                        <div class="form-section">
                            <h3>Host Header</h3>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="enableProxy" name="enableProxy">
                                    Enable Proxy connection
                                </label>
                            </div>

                            <div id="proxySettings" class="proxy-settings hidden">
                                <div class="form-group">
                                    <label for="proxyType">Proxy Type:</label>
                                    <select id="proxyType" name="proxyType" class="dark-select">
                                        <option value="http">http</option>
                                        <option value="socks5">socks5</option>
                                        <option value="https">https</option>
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label for="proxyHost">Proxy Host:</label>
                                    <input type="text" id="proxyHost" name="proxyHost" class="dark-input">
                                </div>

                                <div class="form-group">
                                    <label for="proxyPort">Proxy Port:</label>
                                    <input type="number" id="proxyPort" name="proxyPort" class="dark-input">
                                </div>

                                <div class="form-group">
                                    <label for="proxyUsername">UserName:</label>
                                    <input type="text" id="proxyUsername" name="proxyUsername" class="dark-input" autocomplete="username">
                                </div>

                                <div class="form-group">
                                    <label for="proxyPassword">Password:</label>
                                    <input type="password" id="proxyPassword" name="proxyPassword" class="dark-input" autocomplete="current-password">
                                </div>
                            </div>
                        </div>

                        <div class="form-actions centered">
                            <button type="submit" class="action-button purple">Save</button>
                            <button type="reset" class="action-button">Close</button>
                        </div>
                    </form>
                    <div id="status-message" class="status-message hidden"></div>
                </div>
            </div>
            
            <div class="bottom-panel">
                <div class="listeners-panel">
                    <h3>Active Listeners</h3>
                    <div id="active-listeners" class="listeners-container">
                        <div class="empty-state">Loading listeners...</div>
                    </div>
                </div>
            </div>
        </div>  
    </div>
    <script>
        // Enable/disable proxy settings
        document.getElementById('enableProxy').addEventListener('change', function() {
            const proxySettings = document.getElementById('proxySettings');
            proxySettings.classList.toggle('hidden', !this.checked);
        });

        // Function to add an item to a list
        function addListItem(inputId, listId, hiddenFieldId) {
            const input = document.getElementById(inputId);
            const list = document.getElementById(listId);
            const hiddenField = document.getElementById(hiddenFieldId);
            if (!input.value.trim()) return;
            
            // Create list item element
            const item = document.createElement('div');
            item.className = 'list-item';
            const itemText = document.createElement('span');
            itemText.className = 'item-text';
            itemText.textContent = input.value.trim();
            item.appendChild(itemText);
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-item';
            removeBtn.innerHTML = '×';
            removeBtn.type = 'button';
            removeBtn.onclick = function() {
                list.removeChild(item);
                updateHiddenField(listId, hiddenFieldId);
            };
            item.appendChild(removeBtn);
            
            list.appendChild(item);
            input.value = '';
            
            updateHiddenField(listId, hiddenFieldId);
        }
        
        // Function to update the hidden field with list items
        function updateHiddenField(listId, hiddenFieldId) {
            const list = document.getElementById(listId);
            const hiddenField = document.getElementById(hiddenFieldId);
            const items = Array.from(list.querySelectorAll('.item-text')).map(span => span.textContent);
            hiddenField.value = items.join('\n');
        }
        
        // Function to clear a list
        function clearList(listId, hiddenFieldId) {
            const list = document.getElementById(listId);
            const hiddenField = document.getElementById(hiddenFieldId);
            list.innerHTML = '';
            hiddenField.value = '';
        }

        // Handle form submission with validation
        document.getElementById('listenerForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const formData = new FormData(this);
            const formValues = Object.fromEntries(formData);
            
            // Basic validation
            if (!formValues.listenerName) {
                showError('Listener name is required');
                return;
            }
            
            const listenerConfig = {
                name: formValues.listenerName,
                protocol: formValues.payloadType,
                host: formValues.bindHost,
                port: parseInt(formValues.port, 10)
            };

            // Only add arrays if they have non-empty values
            if (formValues.hosts) {
                const hosts = formValues.hosts.split('\n')
                    .map(h => h.trim())
                    .filter(h => h.length > 0);
                if (hosts.length > 0) {
                    listenerConfig.hosts = hosts;
                }
            }

            if (formValues.hostRotation) {
                listenerConfig.host_rotation = formValues.hostRotation;
            }

            if (formValues.userAgent) {
                listenerConfig.user_agent = formValues.userAgent.trim();
            }

            // Parse and add headers if they exist
            if (formValues.headers) {
                try {
                    const headerPairs = formValues.headers.split('\n')
                        .map(h => h.trim())
                        .filter(h => h.length > 0)
                        .map(h => {
                            const [key, ...values] = h.split(':');
                            return [key.trim(), values.join(':').trim()];
                        });
                    
                    if (headerPairs.length > 0) {
                        listenerConfig.headers = Object.fromEntries(headerPairs);
                    }
                } catch (error) {
                    showError('Invalid header format');
                    return;
                }
            }

            // Parse and add URIs if they exist
            if (formValues.uris) {
                const uris = formValues.uris.split('\n')
                    .map(u => u.trim())
                    .filter(u => u.length > 0);
                if (uris.length > 0) {
                    listenerConfig.uris = uris;
                }
            }

            if (formValues.hostHeader) {
                listenerConfig.host_header = formValues.hostHeader.trim();
            }

            // Add proxy configuration if enabled
            if (formValues.enableProxy === "on") {
                if (!formValues.proxyHost || !formValues.proxyPort) {
                    showError('Proxy host and port are required when proxy is enabled');
                    return;
                }
                
                listenerConfig.proxy = {
                    type: formValues.proxyType,
                    host: formValues.proxyHost.trim(),
                    port: parseInt(formValues.proxyPort, 10)
                };

                if (formValues.proxyUsername) {
                    listenerConfig.proxy.username = formValues.proxyUsername.trim();
                }
                if (formValues.proxyPassword) {
                    listenerConfig.proxy.password = formValues.proxyPassword.trim();
                }
            }

            console.log('Sending listener config:', listenerConfig);
            showLoading('Creating listener...');

            try {
                const response = await fetch('/api/listeners/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(listenerConfig)
                });

                const responseText = await response.text();
                let errorMessage = 'Failed to create listener';
                
                if (!response.ok) {
                    try {
                        const errorJson = JSON.parse(responseText);
                        errorMessage = errorJson.error || errorMessage;
                    } catch {
                        errorMessage = responseText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                showSuccess('Listener created successfully');
                this.reset();
                clearAllLists();
                await refreshListenersList();
            } catch (error) {
                console.error('Error creating listener:', error);
                showError(error.message);
            }
        });

        // Helper functions for status messages
        function showError(message) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = `Error: ${message}`;
            statusMessage.className = 'status-message error';
        }

        function showSuccess(message) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = message;
            statusMessage.className = 'status-message success';
            setTimeout(() => {
                statusMessage.className = 'status-message hidden';
            }, 3000);
        }

        function showLoading(message) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = message;
            statusMessage.className = 'status-message loading';
        }

        function clearAllLists() {
            clearList('hostsList', 'hosts');
            clearList('headersList', 'headers');
            clearList('urisList', 'uris');
        }

        // Input events to allow pressing Enter to add items
        document.getElementById('hostInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                addListItem('hostInput', 'hostsList', 'hosts');
            }
        });
        document.getElementById('headerInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                addListItem('headerInput', 'headersList', 'headers');
            }
        });
        
        document.getElementById('uriInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                addListItem('uriInput', 'urisList', 'uris');
            }
        });

        // Existing functions for managing listeners
        async function updateListenersList() {
            const listenersList = document.getElementById('active-listeners');
            
            // Safety check to prevent null error
            if (!listenersList) {
                console.warn("Element 'active-listeners' not found in DOM");
                return; // Exit early if the element doesn't exist
            }
            
            listenersList.innerHTML = '<div class="loading-spinner">Loading...</div>';
            try {
                const response = await fetch('/api/listeners/list');
                
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                
                const listeners = await response.json();
                console.log("Received listeners:", listeners); // Add logging to debug
                
                if (listeners.length === 0) {
                    listenersList.innerHTML = '<div class="empty-state">No active listeners</div>';
                    return;
                }
                
                let listenersHTML = '';
                for (const listener of listeners) {
                    // Log each listener to debug
                    console.log("Processing listener:", listener);
                    
                    // Extract listener properties, accounting for the nested structure
                    // The ID and other properties might be in the config object
                    const config = listener.config || {};
                    const listenerId = config.id || listener.id;
                    const listenerName = config.name || listener.name || 'Unnamed';
                    const listenerProtocol = config.protocol || listener.protocol || listener.type || 'Unknown';
                    const listenerHost = config.host || listener.host || 'Unknown';
                    const listenerPort = config.port || listener.port || 'Unknown';
                    const listenerStatus = listener.status || 'Unknown';
                    const listenerError = listener.error || '';
                    
                    // Check for valid ID
                    if (!listenerId) {
                        console.warn('Listener missing ID:', listener);
                        continue;
                    }

                    // Debug the extracted values
                    console.log(`Found listener: ID=${listenerId}, Name=${listenerName}, Protocol=${listenerProtocol}`);

                    listenersHTML += `
                        <div class="listener-card" data-id="${listenerId}">
                            <div class="listener-header">
                                <span class="listener-name">${listenerName}</span>
                                <span class="listener-type">${listenerProtocol}</span>
                            </div>
                            <div class="listener-details">
                                <div>Host: ${listenerHost}:${listenerPort}</div>
                                <div>Status: <span class="status-${listenerStatus.toLowerCase()}">${listenerStatus}</span></div>
                                ${listenerError ? `<div class="error-message">Error: ${listenerError}</div>` : ''}
                            </div>
                            <div class="listener-actions">
                                ${listenerStatus.toLowerCase() === 'stopped' ? 
                                  `<button class="action-button success" onclick="startListener('${listenerId}')">Start</button>` : 
                                  `<button class="action-button" onclick="stopListener('${listenerId}')">Stop</button>`}
                                <button class="action-button delete" onclick="deleteListener('${listenerId}', '${listenerName}')">Delete</button>
                            </div>
                        </div>
                    `;
                }
                
                listenersList.innerHTML = listenersHTML || '<div class="empty-state">No active listeners</div>';
            } catch (error) {
                console.error('Error fetching listeners:', error);
                listenersList.innerHTML = `<div class="error-state">Error loading listeners: ${error.message}</div>`;
            }
        }

        async function stopListener(id) {
            if (!id || id === 'undefined') {
                showError('Invalid listener ID');
                console.error('Attempted to stop a listener with invalid ID:', id);
                return;
            }

            console.log(`Stopping listener with ID: ${id}`);
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = "Stopping listener...";
            statusMessage.className = "status-message loading";
            
            try {
                const response = await fetch(`/api/listeners/${id}/stop`, { 
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const responseText = await response.text();
                    let errorMsg;
                    try {
                        const result = JSON.parse(responseText);
                        errorMsg = result.error || `Failed to stop listener (${response.status})`;
                    } catch {
                        errorMsg = responseText || `Failed to stop listener (${response.status})`;
                    }
                    throw new Error(errorMsg);
                }
                
                statusMessage.textContent = "Listener stopped successfully";
                statusMessage.className = "status-message success";
                await updateListenersList();
                
                setTimeout(() => {
                    statusMessage.className = "status-message hidden";
                }, 3000);
            } catch (error) {
                console.error('Error stopping listener:', error);
                statusMessage.textContent = `Error: ${error.message}`;
                statusMessage.className = "status-message error";
            }
        }

        async function deleteListener(id, name) {
            if (!id || id === 'undefined') {
                showError('Invalid listener ID');
                console.error('Attempted to delete a listener with invalid ID:', id);
                return;
            }

            console.log(`Deleting listener with ID: ${id}`);
            if (!confirm(`Are you sure you want to delete ${name}?`)) return;
            
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = "Deleting listener...";
            statusMessage.className = "status-message loading";
            
            try {
                const response = await fetch(`/api/listeners/${id}`, { 
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const responseText = await response.text();
                    let errorMsg;
                    try {
                        const result = JSON.parse(responseText);
                        errorMsg = result.error || `Failed to delete listener (${response.status})`;
                    } catch {
                        errorMsg = responseText || `Failed to delete listener (${response.status})`;
                    }
                    throw new Error(errorMsg);
                }
                
                statusMessage.textContent = `Listener "${name}" deleted successfully`;
                statusMessage.className = "status-message success";
                await updateListenersList();
                
                setTimeout(() => {
                    statusMessage.className = "status-message hidden";
                }, 3000);
            } catch (error) {
                console.error('Error deleting listener:', error);
                statusMessage.textContent = `Error: ${error.message}`;
                statusMessage.className = "status-message error";
            }
        }

        async function startListener(id) {
            if (!id || id === 'undefined') {
                showError('Invalid listener ID');
                console.error('Attempted to start a listener with invalid ID:', id);
                return;
            }

            console.log(`Starting listener with ID: ${id}`);
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = "Starting listener...";
            statusMessage.className = "status-message loading";
            
            try {
                const response = await fetch(`/api/listeners/${id}/start`, { 
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    // Special handling for Method Not Allowed - try the fallback method
                    if (response.status === 405) {
                        console.log("Start endpoint not available, trying fallback method");
                        await handleStartListenerFallback(id);
                        return;
                    }
                    
                    const responseText = await response.text();
                    let errorMsg;
                    try {
                        const result = JSON.parse(responseText);
                        errorMsg = result.error || `Failed to start listener (${response.status})`;
                    } catch {
                        errorMsg = responseText || `Failed to start listener (${response.status})`;
                    }
                    throw new Error(errorMsg);
                }
                
                statusMessage.textContent = "Listener started successfully";
                statusMessage.className = "status-message success";
                await updateListenersList();
                
                setTimeout(() => {
                    statusMessage.className = "status-message hidden";
                }, 3000);
            } catch (error) {
                console.error('Error starting listener:', error);
                statusMessage.textContent = `Error: ${error.message}`;
                statusMessage.className = "status-message error";
            }
        }
        
        // Fallback method to recreate a listener when start endpoint isn't available
        async function handleStartListenerFallback(id) {
            const statusMessage = document.getElementById('status-message');
            
            try {
                // First get the listener configuration
                const response = await fetch(`/api/listeners/${id}`);
                if (!response.ok) {
                    throw new Error(`Failed to get listener details (${response.status})`);
                }
                
                const listener = await response.json();
                console.log("Retrieved listener for recreation:", listener);
                
                // Extract the config from the listener
                const config = listener.config || listener;
                
                // Remove the ID as we're creating a new one
                const newConfig = {...config};
                delete newConfig.id;
                
                statusMessage.textContent = "Recreating listener...";
                
                // Delete the old listener
                const deleteResponse = await fetch(`/api/listeners/${id}`, {
                    method: 'DELETE'
                });
                
                if (!deleteResponse.ok) {
                    throw new Error(`Failed to delete old listener (${deleteResponse.status})`);
                }
                
                // Create a new listener with the same config
                const createResponse = await fetch('/api/listeners/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(newConfig)
                });
                
                if (!createResponse.ok) {
                    throw new Error(`Failed to recreate listener (${createResponse.status})`);
                }
                
                statusMessage.textContent = "Listener started successfully (recreated)";
                statusMessage.className = "status-message success";
                await updateListenersList();
                
                setTimeout(() => {
                    statusMessage.className = "status-message hidden";
                }, 3000);
                
            } catch (error) {
                console.error("Error in fallback listener start:", error);
                statusMessage.textContent = `Error: ${error.message}`;
                statusMessage.className = "status-message error";
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Initial load of listeners
            updateListenersList();
            
            // Set up auto-refresh every 30 seconds
            const AUTO_REFRESH_INTERVAL = 30000; // 30 seconds
            let refreshTimer = setInterval(refreshListenersList, AUTO_REFRESH_INTERVAL);
            
            // Clear interval when page is hidden to save resources
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    clearInterval(refreshTimer);
                } else {
                    // Refresh immediately when page becomes visible
                    refreshListenersList();
                    // Restart the timer
                    refreshTimer = setInterval(refreshListenersList, AUTO_REFRESH_INTERVAL);
                }
            });
        });

        // Safe function to refresh the listeners list that won't throw errors
        function refreshListenersList() {
            const listenersList = document.getElementById('active-listeners');
            if (!listenersList) {
                console.warn("Cannot refresh listeners: Element 'active-listeners' not found");
                return false;
            }
            
            return updateListenersList().catch(error => {
                console.error("Error refreshing listeners list:", error);
                return false;
            });
        }
    </script>
</body>
</html>